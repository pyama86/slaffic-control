package handler

import (
	"fmt"
	"log/slog"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/jellydator/ttlcache/v3"
	_ "github.com/mattn/go-sqlite3"
	"github.com/pyama86/slaffic-control/domain/infra"
	"github.com/pyama86/slaffic-control/domain/model"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
	"github.com/slack-go/slack/socketmode"
)

var defaultChannel = os.Getenv("DEFAULT_CHANNEL")

type Handler struct {
	client        infra.SlackAPI
	userCache     *ttlcache.Cache[string, []slack.User]
	groupCache    *ttlcache.Cache[string, []slack.UserGroup]
	userInfoCache *ttlcache.Cache[string, *slack.User]
	ds            infra.Datastore
	botID         string
}

func NewHandler() (*Handler, error) {
	var ds infra.Datastore
	var err error
	if os.Getenv("DB_DRIVER") == "dynamodb" {
		ds, err = infra.NewDynamoDB()
		if err != nil {
			return nil, err
		}
	} else {
		ds, err = infra.NewDataBase()
		if err != nil {
			return nil, err
		}
	}

	api := slack.New(os.Getenv("SLACK_BOT_TOKEN"))
	return &Handler{
		client:        api,
		userCache:     ttlcache.New(ttlcache.WithTTL[string, []slack.User](time.Hour)),
		groupCache:    ttlcache.New(ttlcache.WithTTL[string, []slack.UserGroup](time.Hour)),
		userInfoCache: ttlcache.New(ttlcache.WithTTL[string, *slack.User](24 * time.Hour)),
		ds:            ds,
	}, nil
}

func (h *Handler) Handle() error {
	webApi := slack.New(
		os.Getenv("SLACK_BOT_TOKEN"),
		slack.OptionAppLevelToken(os.Getenv("SLACK_APP_TOKEN")),
	)
	socketMode := socketmode.New(
		webApi,
	)
	authTest, authTestErr := webApi.AuthTest()
	if authTestErr != nil {
		fmt.Fprintf(os.Stderr, "SLACK_BOT_TOKEN is invalid: %v\n", authTestErr)
		os.Exit(1)
	}
	h.botID = authTest.UserID

	go func() {
		for envelope := range socketMode.Events {
			switch envelope.Type {
			case socketmode.EventTypeEventsAPI:
				socketMode.Ack(*envelope.Request)
				eventPayload, ok := envelope.Data.(slackevents.EventsAPIEvent)
				if !ok {
					slog.Error("Failed to cast to EventsAPIEvent")
					continue
				}
				switch eventPayload.Type {
				case slackevents.CallbackEvent:
					innerEvent := eventPayload.InnerEvent
					switch event := innerEvent.Data.(type) {
					case *slackevents.AppMentionEvent:
						h.handleMention(event)
					case *slackevents.ReactionAddedEvent:
						if event.Reaction == "white_check_mark" {
							h.handleReaction(true, event.Item.Timestamp)
						}
					case *slackevents.ReactionRemovedEvent:
						if event.Reaction == "white_check_mark" {
							h.handleReaction(false, event.Item.Timestamp)
						}
					}
				default:
					slog.Warn("Unsupported EventsAPIEvent type", slog.Any("type", eventPayload.Type))
				}
			case socketmode.EventTypeInteractive:
				socketMode.Ack(*envelope.Request)
				callback, ok := envelope.Data.(slack.InteractionCallback)
				if !ok {
					slog.Error("Failed to cast to InteractionCallback")
					continue
				}
				switch callback.Type {
				case slack.InteractionTypeBlockActions:
					if len(callback.ActionCallback.BlockActions) < 1 {
						return
					}
					action := callback.ActionCallback.BlockActions[0]

					switch action.ActionID {
					case "inquiry_action":
						if err := h.openInquiryModal(callback.TriggerID, callback.Channel.ID); err != nil {
							slog.Error("openInquiryModal failed", slog.Any("err", err))

							return
						}
					case "history_action":
						if err := h.showInquiries(callback.Channel.ID, callback.User.ID); err != nil {
							slog.Error("showInquiries failed", slog.Any("err", err))
							return
						}
					case "mention_action":
						if err := h.openMentionSettingModal(callback.TriggerID, callback.Channel.ID); err != nil {
							slog.Error("openMentionSettingModal failed", slog.Any("err", err))
							return
						}
					}
				case slack.InteractionTypeViewSubmission:
					user, err := h.getUserInfo(callback.User.ID)
					if err != nil {
						slog.Error("GetUserInfo failed", slog.Any("err", err))
						return
					}

					// ÊäïÁ®øËÄÖ„ÅÆÂêçÂâçÔºàË°®Á§∫Âêç„Åå„ÅÇ„Çå„Å∞ÂÑ™ÂÖàÔºâ
					userName := user.Profile.DisplayName
					if userName == "" {
						userName = user.RealName
					}

					switch callback.View.CallbackID {
					case "inquiry_modal":
						// Âïè„ÅÑÂêà„Çè„Åõ„ÅÆÂèó‰ªò
						inputValue := callback.View.State.Values["inquiry_block"]["inquiry_text"].Value
						priority := callback.View.State.Values["priority_block"]["priority_select"].SelectedOption.Value
						channelID := callback.View.PrivateMetadata

						t, err := h.postInquiryRichMessage(channelID, priority, inputValue)
						if err != nil {
							slog.Error("postInquiryRichMessage failed", slog.Any("err", err))
							return
						}

						if err := h.saveInquiry(inputValue, t, channelID, callback.User.ID, userName); err != nil {
							slog.Error("saveInquiry failed", slog.Any("err", err))
							return
						}

					case "mention_setting_modal":
						// „É°„É≥„Ç∑„Éß„É≥„ÅÆ‰øùÂ≠ò
						mentionsRaw := callback.View.State.Values["mention_block"]["mention_text"].Value
						channelID := callback.View.PrivateMetadata
						err := h.saveMentionSetting(mentionsRaw, channelID, userName)
						if err != nil {
							slog.Error("saveMentionSetting failed", slog.Any("err", err))
							if _, err := h.client.PostEphemeral(
								channelID,
								callback.User.ID,
								slack.MsgOptionText(
									fmt.Sprintf(":warning: „É°„É≥„Ç∑„Éß„É≥Ë®≠ÂÆö„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n```%s```", err.Error()),
									false,
								),
							); err != nil {
								slog.Error("Failed to post ephemeral message", slog.Any("err", err))
								return
							}
						}
					}
				}

			default:
				socketMode.Debugf("Skipped: %v", envelope.Type)
			}
		}
	}()

	return socketMode.Run()
}

func (h *Handler) openInquiryModal(triggerID, channelID string) error {
	titleText := slack.NewTextBlockObject("plain_text", "üì© Âïè„ÅÑÂêà„Çè„Åõ„Éï„Ç©„Éº„É†", false, false)
	submitText := slack.NewTextBlockObject("plain_text", "‚úÖ ÈÄÅ‰ø°", false, false)
	closeText := slack.NewTextBlockObject("plain_text", "‚ùå „Ç≠„É£„É≥„Çª„É´", false, false)

	blocks := slack.Blocks{
		BlockSet: []slack.Block{
			// „Éò„ÉÉ„ÉÄ„Éº
			slack.NewHeaderBlock(
				slack.NewTextBlockObject("plain_text", "üì© Âïè„ÅÑÂêà„Çè„Åõ„Éï„Ç©„Éº„É†", false, false),
			),

			// Ë™¨Êòé„ÉÜ„Ç≠„Çπ„Éà
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "*„ÅäÂïè„ÅÑÂêà„Çè„ÅõÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ*", false, false),
				nil, nil,
			),

			slack.NewDividerBlock(),

			// Á∑äÊÄ•Â∫¶ÈÅ∏Êäû
			&slack.InputBlock{
				Type:    slack.MBTInput,
				BlockID: "priority_block",
				Label: &slack.TextBlockObject{
					Type: "plain_text",
					Text: "üö® Á∑äÊÄ•Â∫¶",
				},
				Element: &slack.SelectBlockElement{
					Type:     slack.OptTypeStatic,
					ActionID: "priority_select",
					Options: []*slack.OptionBlockObject{
						slack.NewOptionBlockObject("‰Ωé„ÅÑ",
							slack.NewTextBlockObject("plain_text", "‰Ωé„ÅÑ", false, false), nil),
						slack.NewOptionBlockObject("È´ò„ÅÑ",
							slack.NewTextBlockObject("plain_text", "È´ò„ÅÑ", false, false), nil),
						slack.NewOptionBlockObject("„Ç¶„É´„Éà„É©",
							slack.NewTextBlockObject("plain_text", "„Ç¶„É´„Éà„É©", false, false), nil),
					},
					Placeholder: slack.NewTextBlockObject("plain_text", "ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ", false, false),
				},
			},

			slack.NewDividerBlock(),

			// Âïè„ÅÑÂêà„Çè„ÅõÂÜÖÂÆπ„ÅÆÂÖ•ÂäõÊ¨Ñ
			&slack.InputBlock{
				Type:    slack.MBTInput,
				BlockID: "inquiry_block",
				Label: &slack.TextBlockObject{
					Type: "plain_text",
					Text: "üìù Âïè„ÅÑÂêà„Çè„ÅõÂÜÖÂÆπ",
				},
				Element: &slack.PlainTextInputBlockElement{
					Type:      slack.METPlainTextInput,
					ActionID:  "inquiry_text",
					Multiline: true,
					Placeholder: slack.NewTextBlockObject(
						"plain_text", "ÂÜÖÂÆπ„ÇíË®òÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ", false, false),
				},
			},

			slack.NewDividerBlock(),
		},
	}

	view := slack.ModalViewRequest{
		Type:            slack.ViewType("modal"),
		Title:           titleText,
		CallbackID:      "inquiry_modal",
		Submit:          submitText,
		Close:           closeText,
		Blocks:          blocks,
		PrivateMetadata: channelID,
	}

	_, err := h.client.OpenView(triggerID, view)
	return err
}
func (h *Handler) postInquiryRichMessage(channelID, priority, content string) (string, error) {
	setting, err := h.ds.GetMentionSetting(h.getBotUserID())
	if err != nil {
		return "", err
	}
	first := "Êú™Ë®≠ÂÆö"
	if setting.BotID != "" && setting.Usernames != "" {

		ids := parseCSV(setting.Usernames)
		if len(ids) == 0 {
			_, t, err := h.client.PostMessage(channelID, slack.MsgOptionText("*üì© Êñ∞„Åó„ÅÑÂïè„ÅÑÂêà„Çè„Åõ„ÅåÂ±ä„Åç„Åæ„Åó„Åü*\n>>> "+content, false))
			if err != nil {
				return "", err
			}
			return t, nil
		}

		first = ids[0]
	}
	mention := "Êú™Ë®≠ÂÆö"
	if strings.HasPrefix(first, "S") {
		mention = fmt.Sprintf("<!subteam^%s>", first) // „Ç∞„É´„Éº„Éó„É°„É≥„Ç∑„Éß„É≥
	} else if strings.HasPrefix(first, "U") {
		mention = fmt.Sprintf("<@%s>", first) // „É¶„Éº„Ç∂„Éº„É°„É≥„Ç∑„Éß„É≥
	}

	blocks := []slack.Block{
		// „Éò„ÉÉ„ÉÄ„Éº
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "üì© Êñ∞„Åó„ÅÑÂïè„ÅÑÂêà„Çè„Åõ", false, false),
		),
		slack.NewDividerBlock(),
		// ÊãÖÂΩìËÄÖÊÉÖÂ†±
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*üîî ÊãÖÂΩìËÄÖ:* %s", mention), false, false),
			nil, nil,
		),
		slack.NewDividerBlock(),
		// Âïè„ÅÑÂêà„Çè„ÅõÂÜÖÂÆπ
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*üìù Âïè„ÅÑÂêà„Çè„ÅõÂÜÖÂÆπ:*", false, false),
			nil, nil,
		),
		// Á∑äÊÄ•Â∫¶
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*üö® Á∑äÊÄ•Â∫¶:* %s", priority), false, false),
			nil, nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", fmt.Sprintf(">>> %s", content), false, false), // „Éú„ÉÉ„ÇØ„ÇπÂåñ
			nil, nil,
		),
		slack.NewDividerBlock(),
		// white_check_mark„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´„Å§„ÅÑ„Å¶„ÅÆË™¨Êòé
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "‚úÖ„ÅÆ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ªò„Åë„Çã„Å®„ÄÅ„Åì„ÅÆÂïè„ÅÑÂêà„Çè„Åõ„ÅØÂ±•Ê≠¥„Åã„ÇâË°®Á§∫„Åï„Çå„Å™„Åè„Å™„Çä„Åæ„Åô„ÄÇ", false, false),
			nil, nil,
		),
	}

	// ÊäïÁ®ø
	_, t, err := h.client.PostMessage(channelID, slack.MsgOptionBlocks(blocks...))
	if err != nil {
		return "", err
	}
	return t, nil
}

func (h *Handler) openMentionSettingModal(triggerID, channelID string) error {
	titleText := slack.NewTextBlockObject("plain_text", "„É°„É≥„Ç∑„Éß„É≥Ë®≠ÂÆö", false, false)
	submitText := slack.NewTextBlockObject("plain_text", "‰øùÂ≠ò", false, false)
	closeText := slack.NewTextBlockObject("plain_text", "„Ç≠„É£„É≥„Çª„É´", false, false)

	existing, err := h.ds.GetMentionSetting(h.getBotUserID())
	if err != nil {
		return err
	}

	initialValue, err := h.reverseLookupMentionIDs(existing.Usernames)
	if err != nil {
		return err
	}

	blocks := slack.Blocks{
		BlockSet: []slack.Block{
			&slack.InputBlock{
				Type:    slack.MBTInput,
				BlockID: "mention_block",
				Label: &slack.TextBlockObject{
					Type: "plain_text",
					Text: "„É°„É≥„Ç∑„Éß„É≥„É¶„Éº„Ç∂/„Ç∞„É´„Éº„Éó(„Ç´„É≥„ÉûÂå∫Âàá„Çä)",
				},
				Element: &slack.PlainTextInputBlockElement{
					Type:         slack.METPlainTextInput,
					ActionID:     "mention_text",
					Placeholder:  slack.NewTextBlockObject("plain_text", "@hoge,@dev-team", false, false),
					InitialValue: initialValue,
				},
			},
		},
	}

	view := slack.ModalViewRequest{
		Type:            slack.ViewType("modal"),
		CallbackID:      "mention_setting_modal",
		Title:           titleText,
		Submit:          submitText,
		Close:           closeText,
		Blocks:          blocks,
		PrivateMetadata: channelID,
	}

	_, err = h.client.OpenView(triggerID, view)
	return err
}

func (h *Handler) saveInquiry(message, timestamp, channelID, userID, userName string) error {
	return h.ds.SaveInquiry(&model.Inquiry{
		BotID:     h.getBotUserID(),
		Message:   message,
		Timestamp: timestamp,
		ChannelID: channelID,
		UserID:    userID,
		UserName:  userName,
		CreatedAt: time.Now(),
	})
}

func (h *Handler) getUsers() ([]slack.User, error) {
	cacheKey := "users"
	if users := h.userCache.Get(cacheKey); users != nil {
		return users.Value(), nil
	}
	users, err := h.client.GetUsers()
	if err != nil {
		return nil, err
	}
	h.userCache.Set(cacheKey, users, ttlcache.DefaultTTL)
	return users, nil
}

func (h *Handler) getUserGroups() ([]slack.UserGroup, error) {
	cacheKey := "user_groups"
	if groups := h.groupCache.Get(cacheKey); groups != nil {
		return groups.Value(), nil
	}
	groups, err := h.client.GetUserGroups()
	if err != nil {
		return nil, err
	}
	h.groupCache.Set(cacheKey, groups, ttlcache.DefaultTTL)
	return groups, nil
}

func (h *Handler) getUserInfo(userID string) (*slack.User, error) {
	cacheKey := "user_" + userID
	if user := h.userInfoCache.Get(cacheKey); user != nil {
		return user.Value(), nil
	}
	user, err := h.client.GetUserInfo(userID)
	if err != nil {
		return nil, err
	}
	h.userInfoCache.Set(cacheKey, user, ttlcache.DefaultTTL)
	return user, nil
}

// @ÂêçÂâç ‚Üí ID „ÅÆÂ§âÊèõ
func (h *Handler) findUserOrGroupIDAndDisplayNameByName(name string) (string, string, error) {
	users, err := h.getUsers()
	if err != nil {
		return "", "", err
	}
	groups, err := h.getUserGroups()
	if err != nil {
		return "", "", err
	}

	for _, u := range users {
		if strings.EqualFold(u.Name, name) ||
			strings.EqualFold(u.Profile.DisplayName, name) ||
			strings.EqualFold(u.RealName, name) ||
			strings.EqualFold(u.Profile.RealName, name) {
			if u.Profile.DisplayName == "" {
				return u.ID, u.RealName, nil
			}
			return u.ID, u.Profile.DisplayName, nil
		}
	}
	for _, g := range groups {
		if strings.EqualFold(g.Handle, name) ||
			strings.EqualFold(g.Name, name) {
			return g.ID, g.Name, nil
		}
	}
	return "", "", fmt.Errorf("user or group not found: %s", name)
}

func (h *Handler) saveMentionSetting(mentionsRaw, channelID, userName string) error {
	parsed := parseCSV(mentionsRaw)
	var results []string
	var mentionList []string
	for _, item := range parsed {
		nameOrGroup := strings.TrimPrefix(item, "@")
		nameOrGroup = strings.TrimSpace(nameOrGroup)
		if nameOrGroup == "" {
			continue
		}

		foundID, displayName, err := h.findUserOrGroupIDAndDisplayNameByName(nameOrGroup)
		if err != nil {
			return fmt.Errorf("findUserOrGroupIDAndDisplayNameByName failed: %w", err)
		}

		if foundID == "" {
			return fmt.Errorf("user or group not found: %s", nameOrGroup)
		}
		results = append(results, foundID)
		mentionList = append(mentionList, fmt.Sprintf("%d. %s", len(mentionList)+1, displayName))
	}

	finalCSV := strings.Join(results, ",")
	if err := h.ds.UpdateMentionSetting(h.getBotUserID(), &model.MentionSetting{
		Usernames: finalCSV,
		CreatedAt: time.Now(),
	}); err != nil {
		return fmt.Errorf("Create failed: %w", err)
	}

	// üîπ Block Kit „É°„ÉÉ„Çª„Éº„Ç∏ÊßãÁØâ
	blocks := []slack.Block{
		// „Éò„ÉÉ„ÉÄ„Éº
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", fmt.Sprintf("üìå %s„Åå„É°„É≥„Ç∑„Éß„É≥Ë®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ", userName), false, false),
		),
		slack.NewDividerBlock(),
		// ÂÖÉ„ÅÆÂÖ•Âäõ
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*üìù ÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§:* `%s`", mentionsRaw), false, false),
			nil, nil,
		),
		slack.NewDividerBlock(),
		// Â§âÊèõÁµêÊûú
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*üîó ‰øùÂ≠ò„Åï„Çå„Åü„É°„É≥„Ç∑„Éß„É≥:*", false, false),
			nil, nil,
		),
	}

	// „É°„É≥„Ç∑„Éß„É≥„É™„Çπ„Éà
	if len(mentionList) > 0 {
		for _, mention := range mentionList {
			blocks = append(blocks, slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", mention, false, false),
				nil, nil,
			))
		}
	} else {
		blocks = append(blocks, slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "‚ö†Ô∏è *ÊúâÂäπ„Å™„É°„É≥„Ç∑„Éß„É≥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü*", false, false),
			nil, nil,
		))
	}

	// ÈÄÅ‰ø°
	if _, _, err := h.client.PostMessage(channelID, slack.MsgOptionBlocks(blocks...)); err != nil {
		return fmt.Errorf("PostMessage failed: %w", err)
	}

	return nil
}

// IDs ‚Üí @ÂêçÂâç „ÅÆÈÄÜÂ§âÊèõ
func (h *Handler) reverseLookupMentionIDs(csv string) (string, error) {
	if csv == "" {
		return "", nil
	}
	ids := parseCSV(csv)

	allUsers, err := h.getUsers()
	if err != nil {
		return "", fmt.Errorf("GetUsers failed: %w", err)
	}
	allGroups, err := h.getUserGroups()
	if err != nil {
		return "", fmt.Errorf("GetUserGroups failed: %w", err)
	}

	var result []string
	for _, id := range ids {
		if strings.HasPrefix(id, "U") {
			// „É¶„Éº„Ç∂„Éº
			name := findUserNameByID(id, allUsers)
			if name != "" {
				result = append(result, "@"+name)
			} else {
				result = append(result, "@"+id)
			}
		} else if strings.HasPrefix(id, "S") {
			// „Ç∞„É´„Éº„Éó
			handle := findGroupHandleByID(id, allGroups)
			if handle != "" {
				result = append(result, "@"+handle)
			} else {
				result = append(result, "@"+id)
			}
		} else {
			result = append(result, "@"+id)
		}
	}
	return strings.Join(result, ","), nil
}

func findUserNameByID(userID string, allUsers []slack.User) string {
	for _, u := range allUsers {
		if u.ID == userID {
			return u.RealName // or u.Name
		}
	}
	return ""
}

func findGroupHandleByID(gid string, groups []slack.UserGroup) string {
	for _, g := range groups {
		if g.ID == gid {
			return g.Handle
		}
	}
	return ""
}

func (h *Handler) showInquiries(channelID, userID string) error {
	inquiries, err := h.ds.GetLatestInquiries(h.getBotUserID())
	if err != nil {
		if _, err := h.client.PostEphemeral(channelID, userID, slack.MsgOptionText("üì≠ *Âïè„ÅÑÂêà„Çè„ÅõÂ±•Ê≠¥„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü*", false)); err != nil {
			return err
		}
		return err
	}

	if len(inquiries) == 0 {
		if _, err := h.client.PostEphemeral(channelID, userID, slack.MsgOptionText("üì≠ *Âïè„ÅÑÂêà„Çè„ÅõÂ±•Ê≠¥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì*", false)); err != nil {
			return err
		}
		return nil
	}

	blocks := []slack.Block{
		// „Éò„ÉÉ„ÉÄ„Éº
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "üìú Âïè„ÅÑÂêà„Çè„ÅõÂ±•Ê≠¥", false, false),
		),
		slack.NewDividerBlock(),
	}

	// Slack„ÅÆ„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπÂêç (Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÂèñÂæó)
	workspaceURL := os.Getenv("SLACK_WORKSPACE_URL")

	// Âïè„ÅÑÂêà„Çè„ÅõÂ±•Ê≠¥„Çí„É™„Çπ„ÉàÂåñ
	for _, i := range inquiries {
		t := i.CreatedAt.Format("2006-01-02 15:04:05")

		// Slack„É°„ÉÉ„Çª„Éº„Ç∏URL„ÅÆÁîüÊàê
		slackURL := fmt.Sprintf("%s/archives/%s/p%s", workspaceURL, channelID, i.Timestamp)

		// ÊäïÁ®øËÄÖÂêç„ÅÆÂèñÂæóÔºà„É°„É≥„Ç∑„Éß„É≥„ÅåÈ£õ„Å∞„Å™„ÅÑ„Çà„ÅÜ„Å´Ôºâ
		postedBy := "‰∏çÊòé"
		if i.UserName != "" {
			postedBy = i.UserName // „É°„É≥„Ç∑„Éß„É≥„ÇíÈ£õ„Å∞„Åï„Å™„ÅÑ„Åü„ÇÅ„ÄÅÂçòÁ¥î„Å™ÊñáÂ≠óÂàó
		}

		blocks = append(blocks, slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn",
				fmt.Sprintf("üë§ *ÊäïÁ®øËÄÖ:* %s\nüìÖ *%s*\nüìù [%d] %s\nüìé <%s|Ë©≥Á¥∞„ÇíË¶ã„Çã>",
					postedBy, t, i.ID, i.Message, slackURL),
				false, false),
			nil, nil,
		))
		blocks = append(blocks, slack.NewDividerBlock())
	}

	// „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÔºàÂ±•Ê≠¥„ÅÆ‰∏äÈôê„Å´„Å§„ÅÑ„Å¶Ôºâ
	blocks = append(blocks, slack.NewContextBlock("",
		slack.NewTextBlockObject("mrkdwn",
			"üìå *ÊúÄÊñ∞ 10 ‰ª∂„ÅÆÂ±•Ê≠¥„ÇíË°®Á§∫„Åó„Å¶„ÅÑ„Åæ„Åô*",
			false, false),
	))

	_, err = h.client.PostEphemeral(channelID, userID, slack.MsgOptionBlocks(blocks...))
	return err
}

func parseCSV(csv string) []string {
	csv = strings.TrimSpace(csv)
	if csv == "" {
		return nil
	}
	parts := strings.Split(csv, ",")
	var result []string
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			result = append(result, p)
		}
	}
	return result
}

// startRotationMonitor: Êó•Êú¨ÊôÇÈñì„ÅÆÊúù9ÊôÇ„Å´„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥
func (h *Handler) StartRotationMonitor() {
	dayStr := os.Getenv("ROTATION_DAY") // 0=Êó•,1=Êúà,...,6=Âúü
	if dayStr == "" {
		dayStr = "1" // „Éá„Éï„Ç©„É´„Éà„ÅØÊúàÊõúÊó•
	}
	desiredDay, err := strconv.Atoi(dayStr)
	if err != nil || desiredDay < 0 || desiredDay > 6 {
		slog.Error("Invalid ROTATION_DAY", slog.Any("day", dayStr))
		return
	}

	go func() {
		loc, _ := time.LoadLocation("Asia/Tokyo") // Êó•Êú¨ÊôÇÈñì
		for {
			now := time.Now().In(loc)
			nextRotation := time.Date(now.Year(), now.Month(), now.Day(), 9, 0, 0, 0, loc)

			// „Åô„Åß„Å´9ÊôÇ„ÇíÈÅé„Åé„Å¶„ÅÑ„Åü„ÇâÁøåÊó•
			if now.After(nextRotation) {
				nextRotation = nextRotation.Add(24 * time.Hour)
			}

			// Ê¨°„ÅÆ9ÊôÇ„Åæ„Åß„ÅÆÊôÇÈñì„ÇíË®àÁÆó„Åó„Å¶„Çπ„É™„Éº„Éó
			sleepDuration := time.Until(nextRotation)
			slog.Info("Next rotation", slog.Any("next", nextRotation), slog.Any("sleep", sleepDuration))
			time.Sleep(sleepDuration)

			// ‰ªäÊó•„ÅåÊåáÂÆö„Åï„Çå„ÅüÊõúÊó•„Å™„Çâ„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥„ÇíÂÆüË°å
			now = time.Now().In(loc) // „Çπ„É™„Éº„ÉóÂæå„Å´ÂÜçÂèñÂæó
			if int(now.Weekday()) == desiredDay {
				slog.Info("Rotation time has come, start rotation")
				h.rotateMentions()
			}
		}
	}()
}

func (h *Handler) rotateMentions() {
	setting, err := h.ds.GetMentionSetting(h.getBotUserID())
	if err != nil {
		slog.Error("Failed to get latest mention setting", slog.Any("err", err))
	}

	if setting.BotID == "" || setting.Usernames == "" {
		slog.Info("No mention setting found, skip rotation")
		return
	}

	ids := parseCSV(setting.Usernames)
	if len(ids) < 2 {
		slog.Info("Not enough users/groups for rotation", slog.Any("count", len(ids)))
		return
	}

	// ÂÖàÈ†≠„ÇíÊú´Â∞æ„Å∏
	first := ids[0]
	rotated := append(ids[1:], first)
	first = rotated[0]
	newCSV := strings.Join(rotated, ",")
	setting.Usernames = newCSV
	if err := h.ds.UpdateMentionSetting(h.getBotUserID(), setting); err != nil {
		slog.Error("Failed to save new mention setting", slog.Any("err", err))
		return
	}

	if defaultChannel == "" {
		slog.Warn("No default channel set for rotation")
		return
	}

	// „É°„É≥„Ç∑„Éß„É≥ÊñáÂ≠óÂàó
	var mentionStr string
	if strings.HasPrefix(first, "U") {
		mentionStr = fmt.Sprintf("<@%s>", first) // user mention
	} else if strings.HasPrefix(first, "S") {
		mentionStr = fmt.Sprintf("<!subteam^%s>", first) // group mention
	}

	// ÂÖ®Âì°„ÅÆ„Éè„É≥„Éâ„É´„Éç„Éº„É†„ÇíÂèñÂæó
	allMentions := []string{}
	for _, id := range rotated {
		allMentions = append(allMentions, h.lookupRealNameOrHandle(id))
	}

	// üé® Block Kit „É°„ÉÉ„Çª„Éº„Ç∏ÊßãÁØâ
	blocks := []slack.Block{
		// „Éò„ÉÉ„ÉÄ„Éº (Â§™Â≠ó + ÁµµÊñáÂ≠ó)
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "üåÄ ÊãÖÂΩì„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥", false, false),
		),
		// Ëâ≤‰ªò„Åç„ÅÆ„Ç¢„Ç§„Ç≥„É≥ÔºàÁñë‰ººÁöÑ„Å™Âº∑Ë™øÔºâ
		slack.NewContextBlock("",
			slack.NewTextBlockObject("mrkdwn", ":large_blue_circle: *ÊãÖÂΩì„ÅåÂ§â„Çè„Çä„Åæ„Åó„ÅüÔºÅ*", false, false),
		),
		slack.NewDividerBlock(),
		// Êñ∞„Åó„ÅÑÊãÖÂΩì
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Êñ∞„Åó„ÅÑÊãÖÂΩìËÄÖ:* %s üéØ", mentionStr), false, false),
			nil, nil,
		),
		slack.NewDividerBlock(),
		// ÊãÖÂΩì„É™„Çπ„Éà
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*üìã Êñ∞„Åó„ÅÑÊãÖÂΩìÈ†Ü:*", false, false),
			nil, nil,
		),
	}

	// È†ÜÁï™„É™„Çπ„ÉàÔºàÁï™Âè∑‰ªò„ÅçÔºâ
	for i, mention := range allMentions {
		blocks = append(blocks, slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*%d.* %s", i+1, mention), false, false),
			nil, nil,
		))
	}

	// ÈÄÅ‰ø°
	if _, _, err := h.client.PostMessage(
		defaultChannel,
		slack.MsgOptionBlocks(blocks...),
	); err != nil {
		slog.Error("Failed to post rotation message", slog.Any("err", err))
	}
	slog.Info("Rotation completed", slog.Any("new", first), slog.Any("all", allMentions))

}

// lookupRealNameOrHandle: "Uxxxx" or "Sxxxx" „Çí„É¶„Éº„Ç∂„Éº/„Ç∞„É´„Éº„ÉóÂêç„Å´Â§âÊèõ
func (h *Handler) lookupRealNameOrHandle(id string) string {
	if strings.HasPrefix(id, "U") {
		// user
		u, err := h.getUserInfo(id)

		if err != nil {
			return id
		}
		return u.RealName
	} else if strings.HasPrefix(id, "S") {
		groups, err := h.getUserGroups()
		if err != nil {
			return id
		}
		for _, g := range groups {
			if g.ID == id {
				return g.Handle
			}
		}
	}
	return id
}

func (h *Handler) getBotUserID() string {
	if h.botID == "" {
		authResp, err := h.client.AuthTest()
		if err != nil {
			slog.Error("Failed to get bot user ID", slog.Any("err", err))
			return ""
		}
		slog.Info("Bot user ID", slog.Any("id", authResp.UserID))
		h.botID = authResp.UserID
	}
	return h.botID
}

func (h *Handler) handleReaction(done bool, timestamp string) {
	if err := h.ds.UpdateInquiryDone(h.getBotUserID(), timestamp, done); err != nil {
		slog.Error("Failed to update inquiry", slog.Any("err", err), slog.String("timestamp", timestamp), slog.Bool("done", done))
	}
	slog.Info("Inquiry update", slog.String("timestamp", timestamp), slog.Bool("done", done))
}

// „É°„É≥„Ç∑„Éß„É≥„ÇíÂèó„ÅëÂèñ„Å£„Åü„Å®„Åç„ÅÆÂá¶ÁêÜ
func (h *Handler) handleMention(event *slackevents.AppMentionEvent) {
	channelID := event.Channel
	userID := event.User

	// „Éú„ÉÉ„ÉàËá™Ë∫´„ÅÆ„É°„É≥„Ç∑„Éß„É≥ (`@bot`) „ÇíÂâäÈô§
	messageText := strings.Replace(event.Text, fmt.Sprintf("<@%s>", h.getBotUserID()), "", 1)
	messageText = strings.TrimSpace(messageText) // ‰ΩôË®à„Å™„Çπ„Éö„Éº„Çπ„ÇíÂâäÈô§

	// „ÇÇ„Åó„É°„É≥„Ç∑„Éß„É≥„Å´„ÉÜ„Ç≠„Çπ„Éà„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çå„Å∞„ÄÅÂïè„ÅÑÂêà„Çè„Åõ„Å®„Åó„Å¶Âá¶ÁêÜ
	if messageText != "" {
		priority := "Êú™Ë®≠ÂÆö"

		// Slack API „Åã„ÇâÊäïÁ®øËÄÖ„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
		user, err := h.getUserInfo(userID)
		if err != nil {
			slog.Error("GetUserInfo failed", slog.Any("err", err))
			return
		}

		// ÊäïÁ®øËÄÖ„ÅÆÂêçÂâçÔºàË°®Á§∫Âêç„Åå„ÅÇ„Çå„Å∞ÂÑ™ÂÖàÔºâ
		userName := user.Profile.DisplayName
		if userName == "" {
			userName = user.RealName
		}

		// Âïè„ÅÑÂêà„Çè„Åõ„Çí„É™„ÉÉ„ÉÅ„É°„ÉÉ„Çª„Éº„Ç∏„ÅßÊäïÁ®ø
		timestamp, err := h.postInquiryRichMessage(channelID, priority, messageText)
		if err != nil {
			slog.Error("postInquiryRichMessage failed", slog.Any("err", err))
			return
		}

		// ÊäïÁ®øËÄÖ„ÅÆÊÉÖÂ†±„ÇÇÂê´„ÇÅ„Å¶Âïè„ÅÑÂêà„Çè„Åõ„Çí‰øùÂ≠ò
		if err := h.saveInquiry(messageText, timestamp, channelID, userID, userName); err != nil {
			slog.Error("saveInquiry failed", slog.Any("err", err))
			return
		}
		return
	}

	// „Åì„Åì„Åæ„ÅßÊù•„Åü„Çâ„ÄÅÈÄöÂ∏∏„ÅÆ„É°„Éã„É•„Éº„ÇíË°®Á§∫
	blocks := []slack.Block{
		newSectionBlock("section-1", "*„É°„Éã„É•„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ*", "inquiry_action", "Âïè„ÅÑÂêà„Çè„Åõ„ÇíË°å„ÅÜ"),
		newSectionBlock("section-2", "*Âïè„ÅÑÂêà„Çè„Åõ„ÅÆÂ±•Ê≠¥„ÇíË¶ã„Çã*", "history_action", "Â±•Ê≠¥„ÇíË¶ã„Çã"),
		newSectionBlock("section-3", "*„É°„É≥„Ç∑„Éß„É≥„ÅÆË®≠ÂÆö„ÇíË°å„ÅÜ*", "mention_action", "Ë®≠ÂÆö„Åô„Çã"),
	}

	_, err := h.client.PostEphemeral(
		channelID,
		userID,
		slack.MsgOptionText("„É°„É≥„Ç∑„Éß„É≥„Åï„Çå„Åü„ÅÆ„Åß„ÄÅÈÅ∏ÊäûËÇ¢„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ", false),
		slack.MsgOptionBlocks(blocks...),
	)
	if err != nil {
		slog.Error("Failed to post message with button", slog.Any("err", err))
	}
}

func newSectionBlock(blockID, text, actionID, buttonText string) *slack.SectionBlock {
	return &slack.SectionBlock{
		Type:    slack.MBTSection,
		BlockID: blockID,
		Text: &slack.TextBlockObject{
			Type: slack.MarkdownType,
			Text: text,
		},
		Accessory: &slack.Accessory{
			ButtonElement: &slack.ButtonBlockElement{
				Type:     slack.METButton,
				ActionID: actionID,
				Value:    "dummy_value",
				Text: &slack.TextBlockObject{
					Type: "plain_text",
					Text: buttonText,
				},
			},
		},
	}
}
